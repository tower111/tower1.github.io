##关于free函数对堆的操作
释放堆的全部内容如下
![](http://i4.bvimg.com/659021/ddd11f567342a352.png)

Glibc内存管理中介绍了free的过程不过有一点他是这样说的
```
判断 chunk 的大小和所处的位置,若 chunk_size <= max_fast,并且 chunk 并不位于
heap 的顶部,也就是说并不与 top chunk 相邻,则转到下一步,否则跳到第 6 步。
(因为与 top chunk 相邻的小 chunk 也和 top chunk 进行合并,所以这里不仅需要
判断大小,还需要判断相邻情况)
```
但是实际跟出来的对fast bin的操作有一些改动测试机是ubuntu16
```
add(0x100,"A"*0x10)
add(0x70,"B"*0x21)
delete(2)
delete(1)
gdb.attach(p)
```
跟出来的结果是
```
gef➤ heap chunks
Chunk(addr=0x1ffd010, size=0x110, flags=PREV_INUSE)
[0x0000000001ffd010 78 fb 34 36 78 7f 00 00 78 fb 34 36 78 7f 00 00 x.46x...x.46x...]
Chunk(addr=0x1ffd120, size=0x80, flags=)
[0x0000000001ffd120 00 00 00 00 00 00 00 00 42 42 42 42 42 42 42 42 ........BBBBBBBB]
```
可以看出来2个chunk都还在，0x70的chunk在free的时候并没有跟topchunk进行合并。

